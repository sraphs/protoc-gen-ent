package main_test

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"testing"

	"github.com/jhump/protoreflect/desc/protoparse"
	"github.com/stretchr/testify/require"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"

	"github.com/sraphs/protoc-gen-go_orm/generator"
)

func TestBasic(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/basic.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("basic_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, "type BasicORM struct")
	_, err = tt.fileContents("skipped_orm.pb.go")
	require.EqualError(t, err, `file "skipped_orm.pb.go" not generated`)
	require.Len(t, tt.output, 1)
	require.True(t, strings.HasPrefix(contents, "// Code generated by protoc-gen-go_orm. DO NOT EDIT."))
}

func TestFieldModifier(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/fields.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("fields_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, "type PetORM struct")
	require.Contains(t, contents, `db:"id,pk,autoincrement"`)
}

func TestNested(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/nested.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("nested_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, "type BasicORM struct")
	require.Contains(t, contents, "Nested *Basic_NestedORM")
	require.Contains(t, contents, "Nested *Basic_NestedORM")
	require.Contains(t, contents, "type Basic_NestedORM struct")
}

func TestEdges(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/edges.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("edges_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, `type CatORM struct`)
	require.Contains(t, contents, `type HumanORM struct {`)
}

func TestEnum(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/enums.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("enums_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, `type JobORM struct`)
}

func TestWtk(t *testing.T) {
	tt, err := newGenTest(t, "internal/testdata/wkt.proto")
	require.NoError(t, err)
	contents, err := tt.fileContents("wkt_orm.pb.go")
	require.NoError(t, err)
	require.Contains(t, contents, "type WtkORM struct")
	require.Contains(t, contents, `CreateTime *timestamppb.Timestamp`)
	require.Contains(t, contents, `Ttl        *durationpb.Duration`)
	require.Contains(t, contents, `Json       *structpb.Struct`)
	require.NotContains(t, contents, `CreateTime *timestamppb.TimestampORM`)
	require.NotContains(t, contents, `Ttl        *durationpb.DurationORM`)
	require.NotContains(t, contents, `Json       *structpb.StructORM`)
}

type genTest struct {
	output map[string]string
}

func newGenTest(t *testing.T, files ...string) (*genTest, error) {
	var err error
	tmp, err := ioutil.TempDir("", "protoc-gen-go_orm-")
	require.NoError(t, err)
	t.Cleanup(func() {
		os.RemoveAll(tmp)
	})
	var parser protoparse.Parser
	var descs []*descriptorpb.FileDescriptorProto
	imports := []string{
		"google/protobuf/descriptor.proto",
		"google/protobuf/timestamp.proto",
		"google/protobuf/duration.proto",
		"google/protobuf/struct.proto",
		"orm/opts.proto",
	}
	files = append(imports, files...)
	parsed, err := parser.ParseFiles(files...)
	require.NoError(t, err)
	for _, p := range parsed {
		descs = append(descs, p.AsFileDescriptorProto())
	}
	gen, err := protogen.Options{}.New(&pluginpb.CodeGeneratorRequest{
		FileToGenerate:  files,
		Parameter:       nil,
		ProtoFile:       descs,
		CompilerVersion: nil,
	})
	if err != nil {
		return nil, err
	}

	err = generator.Run(gen)
	if err != nil {
		return nil, err
	}

	resp := gen.Response()

	if resp.GetError() != "" {
		return nil, errors.New(*resp.Error)
	}

	output := make(map[string]string)
	for _, f := range resp.File {
		output[path.Base(f.GetName())] = f.GetContent()
	}

	return &genTest{output: output}, nil
}

func (g *genTest) fileContents(name string) (string, error) {
	contents, ok := g.output[name]
	if !ok {
		return "", fmt.Errorf("file %q not generated", name)
	}
	return contents, nil
}
